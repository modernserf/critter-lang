<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>Critter: a fun, functional-ish programming language</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="stylesheet" href="style.css">
</head>
<body>

<header>
    <h1>Critter</h1>
    <p>
        <strong>Critter is a functional-ish language that compiles to JavaScript.</strong>
        Critter includes persistent data structures, pattern matching, and a syntax that combines the simplicity of Lisp with the readability of scripting languages.
    </p>
    <p>
        Or, rather, it will someday. Critter is currently unimplemented.
    </p>

    <div data-critter-lang>
        import #dom

        let hello(name: name) := {
            [#section [class: #main] [
                [#h1 ["Hello, " name "!"]]
            ]]
        }

        do dom:ready({
            do dom:render(
                dom:find(#body)
                [hello [name: "World"]]
            )
        })
    </div>
</header>

<section class="main-contents">
    <h2>Table of Contents</h2>
    <ol class="contents">
        <li><a href="#overview">What makes Critter different?</a></li>
        <li><a href="#basic-types">Basic types &amp; syntax</a></li>
        <li><a href="#pattern-matching">Pattern matching &amp; conditionals</a></li>
        <li><a href="#error-handling">Error handling</a></li>
        <li><a href="#tables">Tables &amp; relations</a></li>
        <li><a href="#processes">Processes &amp; mutation</a></li>
        <li><a href="#metaprogramming">Metaprogramming</a></li>
        <li><a href="#interop">JavaScript interop</a></li>
    </ol>
</section>

<section id="overview">
    <h2>What makes Critter different?</h2>
    <p>
        <strong>Critter isn't object-oriented.</strong> Not in the traditional sense, anyways. Critter has neither classes nor inheritance. There is no notion of <code>this</code> or <code>self</code>; there is no such thing as a "method", only "functions". However, Critter <em>does</em> have <strong>modules</strong> for organizing related functions, <strong>dot syntax</strong> to simulate method chaining, and <strong>processes</strong> for managing state changes and behavior.
    </p>
    <p>
        <strong>Critter will also disappoint functional programming purists.</strong> Critter features dynamic typing and permits mutation and other side effects. However, Critter promotes a functional style of programming:
    </p>
    <ul>
        <li>data structures are immutable by default</li>
        <li>everything is an expression</li>
        <li>functions called for side effects are made explicit</li>
        <li>error &amp; null handling through variant types and pattern matching</li>
    </ul>
    <p>
        <strong>Critter discourages string manipulation.</strong> Like Ruby, Clojure, and Elixir, Critter uses an <code>#hashtag</code> type in many places where one would use strings in JavaScript. Hashtags are much more restricted than strings: they cannot be created at runtime or generated by user input, cannot contain special characters or whitespace, and cannot be split, concatenated or otherwise parsed. But this makes them safer to work with and limits the amount of parsing your program needs to do:

        <blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">PSA: If a function accepts a string then it&#39;s a parser. Parsers are hard to get right and dangerous to get wrong. Write fewer of them.</p>&mdash; David R. MacIver (@DRMacIver) <a href="https://twitter.com/DRMacIver/status/862642573852258304">May 11, 2017</a></blockquote>
    </p>
    <p>
        <strong>Critter supports relational programming.</strong> Tables are a core data type in Critter and are used where arrays, maps and sets would be in other languages. In addition to the expected map/filter/reduce functions, tables also support complex queries, set operations (union, intersection), and joins. Furthermore, because tables are lazily evaluated, they can be defined in terms of rules and used for Prolog-esque logic programming.
    </p>
</section>

<section id="basic-types">
    <h2>Basic types &amp; syntax</h2>

    <ol class="contents">
        <li><a href="#basic-types--comments">Comments</a></li>
        <li><a href="#basic-types--numbers">Numbers</a></li>
        <li><a href="#basic-types--hashtags">Hashtags</a></li>
        <li><a href="#basic-types--let">Let Bindings</a></li>
        <li><a href="#basic-types--functions">Functions</a></li>
        <li><a href="#basic-types--records">Records</a></li>
        <li><a href="#basic-types--tables">Tables</a></li>
        <li><a href="#basic-types--buffers">Buffers &amp; Strings</a></li>
        <li><a href="#basic-types--modules">Modules</a></li>
    </ol>

    <h3 id="basic-types--comments">Comments</h3>
    <p>Line comments begin with a semicolon.</p>
    <div data-critter-lang>
        ; this is a comment
    </div>
    <h3 id="basic-types--numbers">Numbers</h3>
    <p>
        Numbers are native JavaScript numbers. There are no literals for other bases (binary, octal) or scientific notation.
    </p>
    <div data-critter-lang>
        123     ; integers
        -456    ; negative
        7.89    ; decimal
        0x0F    ; hexadecimal
    </div>

    <h3 id="basic-types--hashtags">Hashtags</h3>
    <p>
        Hashtags are textual identifiers used for named function arguments, named record fields, and tags. They're similar to symbols in Ruby or keywords in Clojure, and are used in many places where strings are used in JavaScript. They can contain any characters except whitespace and the reserved characters <code>: . " ( ) [ ] { }</code>. Characters with multiple representations, such as <code>√©</code>, are canonicalized into a standard form.
    </p>
    <div data-critter-lang>
        #foo #1 #foo/bar #*=!> #üêπ
    </div>

    <h3 id="basic-types--let">Let Bindings</h3>
    <p>
        Define bindings with the <code>let</code> keyword. Bindings have the same restriction as hashtags; additionally, bindings must not start with a digit or <code>-</code> followed by a digit.
    </p>
    <div data-critter-lang>
        let x := 123.45
        let y := #foo
    </div>

    <h3 id="basic-types--functions">Functions</h3>

    <p>
        Functions are defined with curly braces.
    </p>
    <div data-critter-lang>
        let fn := {(x) +(x 2)}
    </div>

    <p>
        Critter employs a form of <a href="https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax">uniform function call syntax</a>:
    </p>
    <div data-critter-lang>
        bar(foo(a b) c d)
        ; is the same as
        a.foo(b).bar(c d)
    </div>

    <p>
        This also means that <strong>Critter does not have operators:</strong> mathematical operators are just regular functions, without operator precedence, character restrictions, or special syntax. They can be used prefix <code>+(1 2)</code> or infix <code>1.+(2)</code>.
    </p>
    <p>
        Functions can take named arguments. Named arguments must come after unnamed arguments. A function with all named arguments will fail when called infix.
    </p>
    <div data-critter-lang>
        let func := {(first second foo: foo-arg bar: bar-arg)
            first.+(second).*(foo-arg)./(bar-arg)
        }
        ; can be called with
        func(1 2 foo: 3 bar: 4)
        1.func(2 foo: 3 bar: 4)
        1.func(2 bar: 4 foo: 3)
    </div>
    <p>
        There is a shorthand syntax for pattern-matching functions by their arguments.
    </p>
    <div data-critter-lang>
        let foo(x) := { +(x 2) }
        let foo(x y) := { +(x y) }

        foo(5)   ; evaluates to 7
        foo(5 1) ; evaluates to 6
    </div>

    <h3 id="basic-types--records">Records</h3>
    <p>
        Records are mixed-type data structures with optionally-named fields. Records can be used as tuples, tagged variants, or simple hashes.
    </p>
    <div data-critter-lang>
        ; positional fields
        let p := [100 200]
        let [x y] := p

        ; named fields
        let p := [x: 100 y: 200]
        let [x: x y: y] := p

        ; tagged variants &amp; pattern matching
        let result := [#ok 123.45]
        let matched := result.match([
            {([#ok value]) value }
            {(#nil)        0 }
        ])
    </div>

    <p>When destructuring, positional fields are mandatory, named fields are optional.</p>
    <div data-critter-lang>
        let p := [100 200 foo: 300]
        ; ok
        let [a b] := p
        let [c _ foo: d] := p

        ; error
        let [foo: e] := p
        let [f] := p
        let [g h i] := p
    </div>

    <p>Records can be applied across function arguments.</p>
    <div data-critter-lang>
        apply([1 2 foo: 3] fn)
        ; is the same as
        fn(1 2 foo: 3)
    </div>

    <h3 id="basic-types--tables">Tables</h3>

    <h3 id="basic-types--buffers">Buffers &amp; Strings</h3>

    <h3 id="basic-types--modules">Modules</h3>

</section>

<section>
    <h2 id="pattern-matching">Pattern matching &amp; conditionals</h2>
    <p>
        Pattern matching: destructuring records, <code>match(value patterns)</code>.
    </p>
    <p>
        Instead of boolean true/false, Critter uses <code>[#ok value]</code> / <code>#nil</code> for logic. This means all logical functions can follow circuit-breaker patterns:
    </p>
    <div data-critter-lang>
        3.<(4).<(5) ; [#ok 5]

        3.<(2).<(5) ; #nil

        [#ok a].and([#ok b]) ; [#ok b]
        [#ok a].or([#ok b]) ; [#ok a]
        [#ok 3].then({(a) +(a 1) }) ; [#ok 4]
        #nil.then({(a) +(a 1) }).else({(_) 5 }) ; [#ok 5]
    </div>
</section>

<section>
    <h2 id="error-handling">Error handling</h2>

    <p>
        Syntax errors, invalid field access crash without recoverability. Crashes can be forced with the <code>exit</code> keyword.
    </p>

    <p>
        APIs with recoverable failure use <code>[#ok value]</code> / <code>[#error value]</code> for error handling. Error variants are also "falsy" in conditionals.
    </p>

    <p>
        <code>assert</code> keyword returns the error if the test fails, continues function if test succeeds
    </p>
    <div data-critter-lang>
        let fn(a b) := {
            assert a.<(3)
            assert b.isa(#number)
            b.+(a)
        }
    </div>
</section>

<section>
    <h2 id="tables">Tables &amp; relations</h2>
</section>

<section>
    <h2 id="processes">Processes &amp; mutation</h2>
</section>

<section>
    <h2 id="metaprogramming">Metaprogramming</h2>
</section>

<section>
    <h2 id="interop">JavaScript interop</h2>
</section>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
<script type="text/javascript" src="highlighter.js"></script>

</body>
</html>
